description = """Данный фреймворк позволяет описать любую модель управления запасами двумя формулами."""

formulas_description = """
- _Формула нахождения точки пополнения заказа_: формула, которая определяет, _нужно ли_ делать заказ.
Данная формула должна вернуть значение TRUE либо FALSE. Соответственно, если формула возвращает TRUE - 
заказ будет размещен в день вычисления формулы.
- _Формула размера заказа_: формула, которая определяет размер заказа (заказ будет размещен в день, 
когда формула нахождения точки пополнения заказа вернула TRUE).
Формула должна вернуть число (кроме того, формула может быть константой - в этом случае каждый раз будет размещаться 
один и тот же размер заказа)
- _Оценивающая функция_ (опционально): функция, которая должна вернуть число. Данная функция используется для оценки качества модели:
например, формула может суммировать общие затраты (если главной задачей является снижение общих затрат).
"""

constants = """
##### Константы
- `S` - сумма потребления за весь период
- `A` - затраты на заказ
- `I` - затраты на хранение
- `Delivery` - время доставки
- `Delay` - время возможной задержки
- `Consumption` - потребление (последовательность)
"""

variables = """
##### Переменные
- `iDay` - индекс текущего дня (начиная с нуля)
- `curBalance` - баланс текущего дня
- `nOut` - количество отправленных но не привезенных заявок
"""

formulas = """
##### Формулы
- `SUM(<последовательность>)` - суммирует диапазон
- `MEAN(<последовательность>)` - находит среднее значение
- `STD(<последовательность>)` - находит стандартное отклонение величины
- `LEN(<последовательность>)` - возвращает длину последовательности
- `MAX(<последовательность>)` - максимальное число из последовательности
- `MIN(<последовательность>)` - минимальное число из последовательности
- `ABS(<число>)` - возвращает модуль числа
- `SQRT(<число>)` - возвращает корень числа
- `ROUND(<число>, <число:опционально>)` - округляет число до целого или до указанного количества знаков (если передан второй аргумент)
"""

math_operations = """
##### Математические операции
- `+` - сложение
- `-` - вычитание
- `*` - умножение
- `/` - деление
- `//` - деление нацело
- `%` остаток от деления
- `**` - возведение в степень
"""

logical_operations = """
##### Логические операции (возвращают TRUE либо FALSE)
- `>` - значение слева больше значения справа
- `<` - значение слева меньше значения справа
- `>=` - значение слева больше или равно значения справа
- `<=` - значение слева меньше или равно значения справа
- `==` - значение слева равно значения справа
- `OR` - логическое "или"
- `AND` - логическое "и"
"""

examples = """
##### Пример 1 - ФРЗ:

В соответствии со стилем и синтаксиса данного минифреймворка, можно переписать, например, метод ФРЗ.

В модели ФРЗ моментом заявки будет служить тот день, когда:
- Уровень запаса опускается ниже порогового уровня
- Предыдущая заявка была привезена

Пороговый уровень определяется как:

```logic
Страховой запас + Ожидаемое потребление за время поставки =
= (Ожидаемое потребление * Возможная задержка поставки) + (Время выполнения заказа * Ожидаемое потребление) =
= ((Потребность / Количество дней) * Возможная задержка поставки) + (Время выполнения заказа * (Потребность / Количество дней)) =
= (S/LEN(Consumption))*Delay + Delivery*(S/LEN(Consumption))
```

Соответственно, _Уровень запаса опускается ниже порогового уровня_ можно записать как:
```login
curBalance <= (S/LEN(Consumption))*Delay + Delivery*(S/LEN(Consumption))
```

На языке фреймворка _Предыдущая заявка была привезена_ будет означать, что количество _Отправленных, но не выполненных 
заявок_ (`nOut`) равно нулю, т.е.: `nOut == 0`

Итого, _Формула нахождения точки пополнения заказа_ будет иметь вид:
```logic
curBalance <= (S/LEN(Consumption))*Delay + Delivery*(S/LEN(Consumption)) AND nOut == 0
```

Формула размера заказа: Q* (фиксированное значение)
Рассчитывается как:

```logic
SQRT((2 * A * S)/I)
```

##### Пример 2 - ФИВ

В модели ФИВ временной промежуток между размещением заказа является постоянным.
Данный интервал вычисляется по формуле `(N*Q)/S`:

```logic
(N * Q) / S =
= (N * SQRT((2 * A * S)/I)) / S =
= (LEN(Consumption) * SQRT((2 * A * S)/I)) / S
```

Соответственно, _Формула нахождения точки пополнения заказа_ будет иметь вид:

```logic
(LEN(Consumption) * SQRT((2 * A * S)/I)) / S AND nOut == 0
```

где `nOut == 0` означает, что новый заказ будет размещен только после того, как будет выполнен предыдущий

Размер заказа варьируется в зависимости от остатка и рассчитывается по формуле:

```logic
Максимальный запас - Наличный запас + Ожидаемое потребление = 
= (Страховой запас + Оптимальный интервал времени между заказами * Ожидаемое потребление) - Наличный запас + (1 / Количество дней) =
= ((Ожидаемое потребление * Возможная задержка) + Оптимальный интервал времени между заказами * (Потребность / Количество дней)) - Наличный запас + (Потребность / Количество дней) =
= (((Потребность / Количество дней) * Возможная задержка) + Оптимальный интервал времени между заказами * (Потребность / Количество дней)) - Наличный запас + (Потребность / Количество дней) =
```

Соответственно, _Формула размера заказа_ будет иметь вид:

```logic
((MEAN(Consumption) * Delay) + ((LEN(Consumption) * SQRT((2 * A * S)/I)) / S) * MEAN(Consumption)) - curBalance + MEAN(Consumption)
```

"""

SHORT_DOC = f"""
{description}
{formulas_description}
{constants}
{variables}
{formulas}
{math_operations}
{logical_operations}
"""

LONG_DOC = f"""
{description}
{formulas_description}
{constants}
{variables}
{formulas}
{math_operations}
{logical_operations}
{examples}
"""
